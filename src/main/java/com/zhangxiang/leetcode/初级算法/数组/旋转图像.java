package com.zhangxiang.leetcode.初级算法.数组;

/**
 * @author: zhangxiang
 * @createTime: 2022年07月02日 16:27:09
 * 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
 *
 * 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
 *
 *  
 *
 * 示例 1：
 *
 *
 * 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
 * 输出：[[7,4,1],[8,5,2],[9,6,3]]
 * 示例 2：
 *
 *
 * 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
 * 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode.cn/problems/rotate-image
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class 旋转图像 {
    /**
     * 1.这是一道观察规律然后进行推算的数学题
     * 2.从最简单的n=2开始找规律,可以发现第i行的第j列旋转之后会变成第j行的倒数第i列,可以表示为m[j][n-1-i]=m[i][j]
     * 3.然后令i'=j,j'=n-1-i,继续推算出m[n-1-i][n-1-j]=m[j][n-1-i]
     * 4.最后可以得出旋转之后这四个点会相互交换位置: m[i][j] -> m[j][n-1-i] -> m[n-1-i][n-1-j] -> m[n-1-j][i] -> m[i][j]
     * 所以每次遍历都是去交换这四个点的位置.
     * 5.然后剩下的问题是如何确定遍历的范围,这点官方题解的解释不详细,我觉得是要证明一下的.
     * 因为每次遍历都是操作4个点,显然我们只需遍历n*n/4个格子即可.
     * 直觉上n*n/4可以等于 (n/2) * (n/2) (即0 <= i < n/2 ,0 <= j < (n/2)),
     * 但也可以等于n * (n/4),究竟是哪种呢?
     * 从最简单的n=2开始观察,可以看到四个格子旋转后都是替换下一个格子,这个可以用上面的公式证明.
     * 然后令n=2k,也就是将每个格子细分,它们的行为并没有发生变化,依旧是大格子去替换顺时针的下一个格子,所以遍历的范围就是原先占1/4面积的大格子了,
     * 即0 <= i < n/2 ,0 <= j < (n/2)
     * 上面是n为偶数的情况,但n为奇数时格子并不能四等分,不适用上述方法.
     * 还是从最简单的n=3开始观察,可以看到多出来的一个格子是正中间的格子,它旋转之后并不会改变位置,所以不需要遍历它.
     * 其余8个格子,四等分为两个相邻的格子,然后旋转,还是可以看到四个格子旋转后替换了下一个格子,从而可以得出0 <= i < n/2 ,0 <= j < ( n+1 /2)
     * 综上,不管n是奇数还是偶数,遍历的范围都可以表示为0 <= i < n/2 ,0 <= j < ( n+1 /2)
     * @param matrix
     */
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        //牢记 第i行的第j列旋转后 会变成 第j行的第 (n-1-i)列
        for (int i = 0; i < n >> 1; i++) { //行
            for (int j = 0; j < (n + 1) >> 1; j++) {//列
                int temp = matrix[i][j];
                // i,j -> j,n-1-i -> n-1-i,n-1-j -> n-1-j,i -> i,j
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = temp;
            }
        }
    }
}
